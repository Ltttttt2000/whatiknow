# 一、树
N个nodes有N-1条边
深度depth = 最深的叶子节点到root，depth(root)=0
高度height = height(root) 到最深节点的长度 

## 树的遍历
前序：根左右
中序：左根右（可确定唯一的树）
后续：左右根
## 树的类型
二叉树
度：向下引出几条边，叶子节点度为0 degree(0)
总边数 = 2\*degree(2)+degree(1) = degree(0) + degree(1) + degree(2) - 1
每个子节点都有一条边引向父节点，每增加一个度为2的就有一个度为0的
degree(2) = degree(0) - 1

完全二叉树

二叉查找树
```
每个node是唯一的key，left<right 每个子树都为ADT
```
二叉平衡树
```
balance factor BF = H(L) - H(R) [-1, 0, 1]
RR rotation构建LR, LL, RL...
```
红黑树

B树
``` 
Order M 
root为叶子或有[2,M]个叶子节点，所有非根节点有 向上取整（M/2）- M个叶子节点
所有叶子的深度相同

```

哈夫曼树
```
层数L，路径长度L-1，带权路径长度WPL= SUM（权值*（L-1）），只算叶子节点的权重
看作有N棵树的森林，选取2个根节点权值最小的tree合并，root为和
```
二叉树的中序遍历in-order traverser 根-左-右
```python
def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
	stack = []
	current = root
	result = []
	while current or stack:
		while current:
			stack.append(current)
			current = current.left

		current = stack.pop()
		result.append(current.val)
		current = current.right

	return result
```

层序遍历
```python
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
	if not root:
		return []
	
	ans, level = [], [root]

	while level:
		ans.append([node.val for node in level])
		tmp = []
		for node in level:
			tmp.extend([node.left, node.right])
			level = [node for node in tmp if node]

	return ans
```
翻转左右子树
```python
def mirrorTree(self, root: TreeNode) -> TreeNode:
	if not root: return

	tmp = root.left
	root.left = self.mirrorTree(root.right)
	root.right = self.mirrorTree(tmp)
	return root
```
# 图论
无向图模型=马尔可夫随机场=Markovnetwork LRF, CRF
有向图 = 贝叶斯网络 = Beliefnetwork

邻接矩阵：N✖️N矩阵：N个顶点，对称矩阵，下三角有X个1，边X条

有向无环图：
```
至少一个点入度为0，一个出度为0
至少有一个拓扑排序
不能转换成树(多个root)，但任何树可成为有向无环图
```
无向图有12个顶点，5个点有5个度，7个点有7个度，图有37条边
解：一条边对应2个度 (7\*7+5\*5)/2 = 37

# 队列
FIFO
length = (rear - front + QueueSize)%QueueSize 
队空 rear = front
队满 (rear + 1)%Q = front
设循环队列中数组的下标范围是1~n，其头尾指针分别为f和r，则其元素个数为（r-f+n）mod n
入队时队尾指针前进1 (rear+1)%QueueSize 插入元素
出队时队头指针前进1 （front+1)%QueueSize 删除元素
队列长度(rear-front+QueueSize)%QueueSize
队满：(rear+1)%QueueSize\==front
队空front=rear

循环队列的存储空间为 Q(1:40) ，初始状态为 front=rear=40 。经过一系列正常的入队与退队操作后， front=rear=15 ，此后又退出一个元素，则循环队列中的元素个数为（ ）
循环队列是队列的一种顺序存储结构，用队尾指针 rear 指向队列中的队尾元素，用排头指针 front 指向排头元素的前一个位置。入队运算时，队尾指针进 1 （即 rear+1 ），然后在 rear 指针指向的位置插入新元素。退队运算时，排头指针进 1 （即 front+1 ），然后删除 front 指针指向的位置上的元素。当 front=rear=15 时可知队列空或者队列满，此后又退出一个元素，如果之前队列为空，退出操作会产生错误，队列里有 0 个元素；如果退出之前队列已满 (40 个元素 ) ，执行退出后，队列里还有 39 个元素。故本题答案为 A 选项


用链接方式存储的队列，在进行插入运算时 (头、尾指针可能都要修改   ).一般情况下，仅需修改队尾指针； 但当队列为空时，插入元素时，队头和队尾指针都需修改
删除运算时也是。在有头结点的链队列的出队操作中，一般只需修改队头指针，但当原队列中只有一个结点时，该结点既是队头也是队尾，故删去此结点时亦需修改队尾指针，使其指向头结点，且删去此结点后队列变空。 

设指针变量fron t 表示链式队列的队头指针，指针变量rear表示链式队列的队尾指针，指针变量s指向将要入队列的结点X，则入队列的操作序列为（）。rear->next=s；rear=s；

二叉排序树中，查找的平均时间复杂度是O(logn)； 对于栈和队列来说，查找就意味着把元素挨个出栈或者出队，故平均时间复杂度是O(n)； 而哈希表，直接通过关键码查找元素，平均为O(1)； 故哈希表速度是获取一个指定值最快的


后缀
表达式"X=A+B*(C-D)/E"的后缀表示形式可以是（）XABCD-*E/+=
从左到右依次遍历，遇到变量输出，遇到运算符入栈
1. Output: X   栈
2. Output: X   栈: =
3. Output: XA   栈: =
4. Output: XA   栈: =+
5. Output: XAB   栈: =+
6. Output: XAB   栈: =+*
7. Output: XAB   栈: =+*(
8. Output: XABC   栈: =+*(
9. Output: XABC   栈: =+*(-
10. Output: XABCD   栈: =+*(-
11. 遇到)出栈 Output: XABCD-   栈: =+*
12. 遇到/ *出栈 /入栈 Output: XABCD-*   栈: =+/
13. Output: XABCD-*E  栈: =+/
14. 遍历完成 出栈 Output: XABCD-*E/+=

下面哪种数据结构最适合创建一个优先级队列(堆)
4种结构都可以构建优先队列。    但双向链表、 单向链表、 栈 入队，出队需要搜索全部元素。    所以堆最合适。  

解析XML时，需要校验节点是否闭合，如必须有与之对应，用（）数据结构实现比较好
栈是解决封闭对应问题的有效方法。 比如在解析XML中，遇到一个<demo>标签（左标签）就入栈，遇到其子标签的左标签（如<subdemo>）同样入栈。遇到右标签(如</subdemo>或</demo>)就校验栈顶标签是否与该右标签对应，能对应就出栈，不能对应则说明标签不对称，是无效的XML文件

将新元素插入到链式队列中时，新元素只能插入到（  链尾  ） 队列尾部插入，删除从头部

STL中的优先队列是采用什么数据结构来实现的？ 堆
STL主要包含了容器、迭代器、算法和string四部分  
STL中的priority_queue，它就是用堆实现的，插入或删除不需要排序，只是一个调整堆的过程。 

线性表是线性结构，栈与队列都是线性结构； 二叉树是层次结构


设栈S和队列Q的初始状态均为空，元素a，b，c，d，e，f，g依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是b，d，c，f，e，a，g，则栈S的容量至少是（3）。
队列是先进先出，栈是先进后出
元素a沉底了，然后d和c要一起出去，所以Stack从下往上分别是a c d，至少要三个位置。 
进栈a→ab   b出栈    b入队出队     出队顺序  b     S(1) 
进栈abcd    dc出栈   dc入队出队   出队顺序 bdc   S(2) 
进栈adcdef  fe出栈   fe入队出队   出队顺序 bdcfe S(3) 

   队空时： front=rear
   队满时： (rear+1)%maxsize=front 
   
执行（广度优先搜索图）操作时，需要使用队列作为辅助存储空间。
图的拓扑排序，深度优先 关键路径算法用的栈辅助；树的层次遍历 图的广度优先遍历用的队列辅助


有一个虚拟存储系统，若进程在内存中占3页（开始时内存为空），若采用先进先出（FIFO）页面淘汰算法，当执行如下访问页号序列后1，2，3，4，5, 1，2，5，1，2，3，4，5，会发生多少缺页？ 10
当我们存入队列的数字在内存中已经有的时候就不缺页，没有就缺页；且是先进先出的原则。 FIFO（first in first out）：先进先出页面置换算法，按照时间顺序替换页面，呆的越久的，很可能以后再用不到了。  
当我们存入队列的数字在内存中已经有的时候就不缺页，没有就缺页 


递归算法一般用（栈）实现
今天说的是栈与递归的关系，函数的递归调用和普通函数调用是一样的。当程序执行到某个函数时，将这个函数进行入栈操作，在入栈之前，通常需要完成三件事。 1、将所有的实参、返回地址等信息传递给被调函数保存。 2、为被调函数的局部变量分配存储区。 3、将控制转移到北调函数入口。  当一个函数完成之后会进行出栈操作，出栈之前同样要完成三件事。 1、保存被调函数的计算结果。 2、释放被调函数的数据区。 3、依照被调函数保存的返回地址将控制转移到调用函数。  上述操作必须通过栈来实现，即将整个程序的运行空间安排在一个栈中。每当运行一个函数时，就在栈顶分配空间，函数退出后，释放这块空间。所以当前运行的函数一定在栈顶。


设数据结构 B=(D, R) ，其中

D={ a, b, c, d, e, f }

R={ (a, b ） , (b, c ） , (c, d ） , (d, e), (e, f), (f, a） }

该数据结构为（非线性结构 ）。
D相当于一个顶点的集合，R相当于一个边的集合，所以，B是一个图，即非线性结构    
数据的逻辑结构有两个要素：一是数据元素的集合，通常记为 D ；二是 D 上的关系，它反映了 D 中各数据元素之间的前后件关系，通常记为 R 。即一个数据结构可以表示成 B= （ D,R ）。其中 B 表示数据结构。为了反映 D 中各数据元素之间的前后件关系，一般用二元组来表示。例如，假设 a 与 b 是 D 中的两个数据，则二元组（ a,b ）表示 a 是 b 的前件， b 是 a 的后件。 如果一个非空的数据结构满足下列两个条件：①有且只有一个根结点；②每一个结点最多有一个前件，也最多有一个后件。则称该数据结构为线性结构。如果一个数据结构不是线性结构，则称之为非线性结构。 本题数据结构中没有根结点，因此它是非线性结构。


开源软件经常被用作队列的：Redis, kafka
栈、队列的插入和删除操作时间复杂度应该都是O(1)  

某带链的队列初始状态为 front=rear=NULL 。经过一系列正常的入队与退队操作后， front=rear=10 。该队列中的元素个数为（1 ）
往队列的队尾插入一个元素为入队，从队列的排头删除一个元素称为退队。初始时 front=rear=0 ， front 总是指向队头元素的前一位置，入队一次 rear+1 ，退队一次 front+1 。队列队头队尾指针相同时队列为空。而带链的队列，由于每个元素都包含一个指针域指向下一个元素，当带链队列为空时 front=rear=Null ，插入第 1 个元素时， rear+1 指向该元素， front+1 也指向该元素，插入第 2 个元素时 rear+1 ， front 不变，删除 1 个元素时 front+1 。即 front=rear 不为空时带链的队列中只有一个元素。故本题答案为 A 选项。
注意看是带链的队列，不要看成循环队列


已知输入序列为abcd经过输出受限的双向队列后能得到的输出序列有()
输出受限意为可以在两端输入只能在一端输出
因为a、b、c先于 d入队且d先于a、b、c出队，所以当d出队时a、b、c还在队中。 
对于a、b、c而言： a，b先入队，此时a和b的排列顺序为ab或ba，所以当c入队时，只能排在在ab或ba的两端。 
即不能出现c夹在a和b中间的情况， 也就是不能出现...d...b...c...a...和...d...a...c...b...这两种情况。  

 队列的链式存储结构成为链队列，它是限制仅在表头删除和表尾插入的单链表，队头在链头位置。 
队头插入，队尾删除。 所以队头对应链表的表头，队尾对应链表的表尾。 

队列属于逻辑结构的概念，它们的物理存储既可以利用数组也可以利用链表完成，所以循环队列属于逻辑上首尾相接的抽象圆环
循环队列空队列头尾指针指向同一个区域（0区域），所以F==R；满队列是随着元素的入队，尾指针逐渐加1，直到从0区域加到SIZE-1区域，这时尾指针指向SIZE-1区域，头指针指向0区域。判断队满的条件是尾指针再加1（由于是循环）所以头尾指针重合在0区域，（R+1）%SIZE==F


循环队列存储在数据A[0..m]中，则入队时的操作为___rear=(rear+1)%(m+1)___ 。 救命 一共有m+1个元素


线性表
顺序存储：在一块连续的存储区域一个接着一个的存放数据。顺序存储方式把逻辑上相邻的节点存储在物理位置放在相邻的存储单元里，节点间的逻辑关系由存储单元的邻接关系来体现。顺序存储方式也称为顺序存储结构，一般采用数组或结构数组来描述。 
优点： 在结点等长时可以随机存取 存储密度高节省存储空间 用结点的物理次序反映结点之间的逻辑关系 缺点： 插入和删除结点时要移动大量的结点 必须静态分配连续空间 
链接存储：链接存储方式比较灵活，不要求逻辑上相邻的节点在物理位置上相邻，节点间的逻辑关系由附加的引用字段来表示。一个节点的引用字段往往指向下一个节点的存放位置。链接存储方式也成为链式存储结构。 优点： 插入和删除比较灵活，不需要大量移动结点 动态分配空间比较灵活，不需要预先申请最大的连续空间 缺点： 增加指针的空间开销 检索必须沿链进行，不能随机存取 
因此D（插入删除比较灵活）不是顺序存储的优点，而是链接存储的优点。

对于序列（ 12 ， 13 ， 11 ， 18 ， 60 ， 15 ， 7 ， 19 ， 25 ， 100 ），用筛选法建堆，必须从值为 ___60_____ 的数据开始建初始堆
有n个元素的序列，若使用筛选法建堆，则从位置为n/2取下整的元素开始建堆 


大小为MAX的循环队列中，f为当前对头元素位置，r为当前队尾元素位置(最后一个元素的位置)，则任意时刻，队列中的元素个数为
(r-f+MAX+1)%MAX
正常情况下rear指向队尾元素的下一个位置，f为当前对头元素位置 本题是指向队尾元素的位置。

有序线性表既可以采用顺序存储结构，也可以采用链式存储结构

采用非递归方式重写递归程序时必须使用栈：错误，计算斐波拉契数列迭代只用一个循环即可
函数调用时，系统通常要用栈保存必要信息。
只要确定了入桟次序，即可确定出栈次序：错误，可能边入边出

若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（）
卡特兰数，相关问题还有：已知前序遍历的顺序是xxxx求这棵树有多少种形状 C(2*N,N)/(N+1) 


Windows中的堆和栈
堆都是动态分配的，没有静态分配的堆；栈有动态和静态分配两种方式
对堆的频繁new/delete会造成内存空间的不连续，从而造成大量的碎片;栈则不会存在这个问题
栈是由编译器自动治理；堆的释放工作由程序员控制，轻易产生内存泄露。
栈区（stack）由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆区（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事。
区别：   
1. 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存溢出。   
2. 空间大小：堆内存几乎是没有什么限制。栈一般都是有一定的空间大小。  
3. 碎片问题：对于堆来讲，频繁的new/delete会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。   
4. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。   
5. 分配效率：栈的效率比较高。堆的效率比栈要低得多。 
6. 增长方向：堆的增长方向是从程序低地址到高地址向上增长，而栈的增长方向刚好相反（实际情况可能不是这样的，与CPU的体系结构有关）


前缀中缀后缀表达式的转换
在中缀变后缀时，操作数的顺序不会发生变化，只有运算符的顺序可能发生变化。同时又没有括号。所以在转换的过程中，只要碰到操作数，可以直接输出，而遇到运算符和括号进行相应的处理即可。 
1.从左到右读取一个中序表达式。 
2.若读取的是操作数，则直接输出。 
3.若读取的是运算符，分三种情况。 
    A.该运算符为左括号（ ，则直接存入堆栈。 
    B.该运算符为右括号），则输出堆栈中的运算符，直到取出左括号为止。
    C.该运算符为非括号运算符，则与堆栈顶端的运算符做优先权比较，若较堆栈顶端运算符高或者相等，则直接存入堆栈；若较堆栈顶端运算符低，则输出堆栈中的运算符。 
4.当表达式已经读取完成，而堆栈中尚有运算符时，则依次序取出运算符，直到堆栈为空，由此得到的结果就是中缀表达式转换成的后缀表达式。

a/b+(c*d-e*f)/g
+入栈时会把/挤出栈
# 栈
LIFO

# 数组
设有一个二维数组A[m][n]，假设A[0][0]存放位置在 644，A[2][2]存放位置在676，每个元素占一个空间，问A[3][3]存放的位置在（ 692） 要算出每一行都占多少
在一个长度为n的顺序表中删除第i个元素，要移动___n-i____个元素。如果要在第i个元素前插入一个元素，要后移___n-i+1_____个元素。

各种排序的算法为代码和每一步的过程
插入排序；基数排序；快速排序；起泡排序

Java语句创建数组 String a[];  String[] a; Object a[]; Java声明数组时不能直接限定数组长度，只有在创建实例化对象时才能给丁长度 String a[] = new String[50]

数组元素的地址计算与数组的存储方式无关。错误
分行优先还是列优先；顺序存储时间复杂度为O(1)；链式存储时间复杂度为O(n)


已知定义如下代码段 ，则以下哪个选项结果为5。()
int a[] = {1, 2, 3, 4, 5, 6, 7, 8};
char s = 'a', e, i;

a['e'-s], s为字符'a' 'e'-'a'的字符之间的ASCII码十进制为4
在表长为n的顺序表上做插入运算，平均要移动的结点数为（ n/2）
假设长度为n数组a, 从数组最前(插到a[0]前)到最后(插到a[n-1]后)共n+1种情况，分别需要移动n,n-1,...,0次，每种情况等概率P=1/(n+1), 期望为(n+n-1+...+0)/(n+1) = (1+n)*n/2/(n+1)=n/2 

数组作为函数参数传递的是：数组的首地址
线性表采用链式存储时其地址连不连续都可以。


二分查找的次数

C语言中 一维数组的定义方式为 元素类型 数组名[E] E为整形常量表达式代表元素的个数 （整形表达式为x+y这种）

设一维数组中有n个数组元素，则读取第i个数组元素的平均时间复杂度为：O(1)正常读取数组下标是常数

int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）
int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）
int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）




已知定义数组 char a[3];，以下哪个选项不能代表数组元素a[1]的地址:&a[0]++
在C语言中，数组的地址和数组中第一个元素的地址相同。数组中第一个元素地址的表示方法为&a[0] = a; 数组元素地址不可以做自增运算

二维数组k[1..7,1..9]，每元素大小占2个字节，而且使用列存储，a[5,4]的偏移量为（50）个字节。

### 数组指针和函数指针
声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）
int (*(*p)[10])(int *)
首先题目说要声明一个数组指针,  一般我们想到的数组指针是 随便来一个 int(*p)[10],  然后又说每个元素是一个函数指针,那么我们随便来一个 函数指针  int (*pf)(int *). 然后把(*p)[10]作为一个整体替代pf 即   int(*(*p)[10]))(int *);    
分析:判断一个复杂式子看最高优先级的,*p是一个指针,然后(*p)外面是[],所以是数组指针,(*p)[10])描述完毕,然后再看外面int(*)(int *)很明显,这是一个函数指针,所以这个数组中每个元素是函数指针    

有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是(66)
将非零元素所在行、列、非零元素的值构成一个三元组（i，j，v）每个非零元素占3*2=6个字节，共10个非零元素，需6*10 = 60 个字节； 
此外，还一般要用三个整数来存储矩阵的行数、列数和总元素个数，又需要3*2 = 6个字节；
每个元素要用行号,列号,元素值来表示,在用三元组表示稀疏矩阵,还要三个成员来记住,矩阵的行数列数,总的元素数,所以所需的字节数是10*（1+1+1）*2+3*2=66 

注意数组的初始化int a[10]=(0,0,..)不是括号！应该是{}

算二维数组的存储地址，注意行列

原生类指未被实例化的类,数组一般指实例化,被分配空间的类,不属于原生类.
稀疏矩阵压缩的存储方法是：
三元组（可以节省空间，但当矩阵运算时需要大量移动元素）/十字链表（避免大量移动元素）
而散列表下标只能存一个元素，要么行下标要么列下标，所以不行

在一个长度为n的顺序表的任意位置插入一个新元素的渐进时间复杂度为O（N）
渐进时间复杂度是指n趋于无穷时的复杂度。向有序表中任意一个位置插入元素，插入位置之后的元素依次挪动一个位置，假设元素插入的位置坐标为k，则时间复杂度为O(k)，渐进时间复杂度为O(n)  

int A[2][3]={1,2,3,4,5,6}; 则A[1][0]和*(*(A+1)+1)的值分别是4，5
数组A一共2行3列，第0行为123，第1行为456 A[1][0]为第1行第0列数字4 
A 是二维数组名, 在参与运算时候会退化成指针。A这个指针的值和 二维数组中第00个元素的地址一样,即   A   ==   &A[0][0]       
*A表示第0行的首地址 *A=&A[0][0]=A A表示二维数组的首地址-->*（A+1）指向数组第1行第0个元素首地址，*（A+1）+1指向数组第1行第1个元素 再取*则为第1行第1个元素的值5 （实际为[1][1]元素的地址）

冒泡排序最坏复杂度O(N^2)


向一个长度为n的向量的第i个元素(1≤i≤n+1)之前插入一个元素时，需向后移动 (n-i+1) 个元素
前面i-1个元素不动，那么就要移动n-（i-1）个元素了

已知定义数组char a[6]，若要用来接收输入5个字符，以下错误的是()
gets(&a[0]) 正确：gets()是从输入缓冲区中读取一个字符串储存到字符指针变量str所指的内存空间
gets(a)正确:参数类型为 char* 型，即 str 可以是一个字符指针变量名，也可以是一个字符数组名。
scanf("%s", a+1) 正确：C选项中，a+1是数组元素a[1]的地址，因为数组长度为6，所以用来接收5个字符没有问题。
scanf("%s", a[0])错误：a[0]不是地址，而是数组元素
gets和scanf输入都是需要取地址，数组名a等价于首元素地址&a[0]，a+1相当于&a[1]




线性表除第一个和最后一个元素外，其余每个元素都有且仅有一个直接前驱和直接后继，可以为空

定义数组#define SIZE 10 int a[SIZE]

链表和数组的区别：
链表是链式存储结构，数组是顺序存储结构；
链表通过指针连接元素，而数组则是把所有元素按顺序进行存储；
链表插入和删除元素不需要移动元素，数组删除和增加元素需要移动元素。

c中，二维数组初始化的方法是:int a[3][3]={{1},{2},{3}}; 说法正确，后续会默认成0
char s[ ]=”china”; char *p; p=s; p=s;
将指针P指向数组S的内存首地址。 p申请的内存空间存放的是s首地址的内存空间，而s的连续内存空间存放的china，所以p!=s。 数组s的内容是china,而指针p内容为s的地址。 s数组的长度为6（包含结束符'\0'），p所指向的字符串长度为5。*p=s[0]
C语言规定，二维数组定义时不允许省略第二维的长度

下三角矩阵

Java定义数组：int score[] = new int[10]; int[] score = new int[10];
线性表的顺序存储结构是一种随机存取的存储结构

char str[2][3]表示声明了一个字符串的数组,最多可以存放两个字符串，每一个字符串的长度为3。题中{"a","b","c"}为三个字符串 所以错误 char b[2][3]={"a","b","c"};

对于长度为n的线性表，建立其对应的单链表的时间复杂度为O（N)无论采用什么方式建立单链表，都需要扫描这n个元素，边扫描边创建单链表中的结点并链接起来，其时间复杂度为O(n)。  我们使用头插式或尾插式创建链表都只需要一次循环遍历就可实现，所以时间复杂度为O(n)。


数组名代表的是数组的首地址，是一个地址常量，所以不能给数组名赋值
strcpy(s1, s2) 将s2复制到s1中

原生类有8种， int double boolean float byte short long char


Array对象常用方法中：
不改变原数组：
concat():连接两个或多个数组,不改变原数组,返回被连接数组的一个副本 
join():把数组中所有元素放入一个字符串,不改变原数组,返回字符串 
slice():从已有的数组中返回选定的元素,不改变原数组,返回一个新数组 
toString():把数组转为字符串,不改变原数组,返回数组的字符串形式 
改变原数组：
pop():删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined 返回被删除的元素 
push():向数组末尾添加一个或多个元素改变原数组,返回新数组的长度 
reverse():颠倒数组中元素的顺序 返回该数组 
shift():把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined 返回第一个元素的值 
sort():对数组元素进行排序(ascii) 返回该数组 
splice():从数组中添加/删除项目 返回被删除的元素 
unshift():向数组的开头添加一个或多个元素  返回新数组的长度 
 
数组常用的两种基本操作是：查找与修改
数组下标值越大存取时间越长：错误：存取不等于插入删除，存取就是赋值

对称矩阵压缩，按主对角线有N个，再加上剩下的一半

var array=[-1,1,3,4,6,10];
array.sort((a,b)=>Math.abs(a-3)-Math.abs(b-3));
array = [3,4,1,6,-1,10]
array.sort(sortFunction)是按照sortFunction结果大小排序即数值减3的绝对值[4，2，0，1，3，7]作为参数决定排序。


线性表的长度是线性表所占用的存储空间的大小。 False 线性表长度的定义是它所包含的元素的个数。 

只有一个根结点的数据结构不一定是线性结构。
线性结构应满足：有且只有一个根结点与每个结点最多有一个前件，也最多有一个后件。所以有一个以上根结点的数据结构一定是非线性结构，循环链表和双向链表都是线性结构的数据结构。
线性结构有：串，链式存储栈，顺序存储栈
线性是线性，顺序是顺序，线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元素或节点，非线性是一个元素后面可以有多个后继或前继节点，顺序是指存储结构连续，例如数组是顺序的，链表不是顺序的，但他们都是线性的。当然顺序也可以是非线性的，例如顺序结构存储非线性结构的二叉树！！！



char s[20]="programming",*ps=s ；
ps是指针 ps+2为一个地址 *(ps+2)=‘o'

### 数组和链表的区别
数组静态分配内存，并在内存中连续；链表动态分配内存但不连续
查询时，数组下标查询的时间复杂度为O（1），数组元数查询的时间复杂度为O（N）
插入或删除元素时，链表（插入首尾结点）的时间复杂度为O（1）中间的需要线找到位置所以也是O（N），数组为O（N） 

数组元素在栈区，链表元素在堆区。static 一个数组是静态区 ，malloc一个数组是堆区，局部变量的数组是分配在栈区的吧 
返回随机结点数组更快（指哪打哪）数组的优点，查找O(1) 
双向链表原地逆序很快

数组从栈中分配空间，链表从堆中分配空间
数组也可以是new的，链表也可以是用数组模拟的~~ 
 
动态数组是在堆上创建


 
 

假设以行优先顺序存储三维数组A[5][6][7],其中元素A[0][0][0]的地址为1100，且每个元素占2个存储单元，则A[4][3][2]的地址是(1482)
把三维坐标想象成立方体。分配的空间A[5][6][7]表示层高为5、行数为6、列数为7 
因为数数的基本单位其实是列，二维坐标是行号列号，虽然平时可能习惯行号列号层号，但是按照二维的规律，那么三维坐标应该是层号行号列号 那么A[4][3][2]中4、3、2分别对应这个点的层数、行号、列号 
位置为4*(6*7)+3*7+2=191 每个元素两个存储单元，最终结果为191*2+1100=1482 

在C语言中，若有定义：int a[4][10](其中0<=i<4,0<=j<10);则下列选项中对数组元素a[i][j]引用
*(a+i)+j 是a[i][j]的地址 再取指针才是值*(*(a+i)+j)
或者*(&a[0][0]+10*i+j)为 先取地址再取值
或者*(a[i]+j)正确，a[i]是第i行第0个元素的地址，+j后是a[i]][j]的地址，再取*为值

若稀疏矩阵采用三元组表形式进行压缩存储,若要完成对三元组表进行转置,只要将行和列对换,这种说法(错误)。
三元组转置：行列互换，然后再按行排序。

在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行（9）次比较
比如 A B C D E F G H，通过8进4的方式，A与B比较， C与D比较.....然后再4进2，A与C比较（假设A,C比B,D大），E与G比较。再2进1，比如A与E比较（假设A，E比C,G大）选出最大的A，总共7次。    然后次大的数一定是被最大数PK下去的，所以再选B C E三个比较2次得到次大的数                                                      A                              A                                              E                A                          C                    E                   G    （7次）        A             B            C           D       E          F      G           H   再选 BCE中最大的（2次），共9次，不过可以这个方法比较次数是少一点，但是所需要的空间大，要记下与沿途的最大值比较的数。
画图看 
接着拿第三次分组中与最大比较的那个数分别和  之前与最大那个数比较过的数比较  分别是第一次分组有一个   第二次分组有一个  7+2=9    

数组指针只是一个指针变量，它占有内存中一个指针的存储空间
指针数组是多个指针变量，以数组形式存在在内存中，占有多个指针的存储空间


指针可以随时指向任意类型的内存卡 （错误） const类型不行

在定义 int a[3][4][2]; 后，第 20 个元素是（ a[2][1][1]）
三维数组可以看成是一本书！ int a[3][4][2]; 就是有3页每页4行2列

用数组r存储静态链表,结点的next域指向后继,工作指针j指向链中结点,使j沿链移动的操作为
j = r[j].next
j = j->next不对 当前结点是r[j],可以排除

char str[10] = "output";
printf("\"%s\"\n", str);
输出"output"  第一个是转移字符 要打出双引号，第二个表示在次数输出字符串，第三个表示换行 


定义数组char a[][3] = {1,2,3,4,5,6,7,8}，则数组a的第一维的大小是多少。 (3)
由题目知二维数组的列为3，一共有8个元素，所以行为3，第一维大小为3，第二维大小为3，第三维大小为2
最后一个元素是\0

int(*s)[8]等价于 s[][8]
int *s[8] 等价于有8个指向int指针的数组


二维以上的数组其实是一种特殊的广义表，数组一旦建立，结构的元素个数和元素间的物理存储关系就不再变化。
数组采用顺序存储方式表示。
数组也能存储二叉树（不一定只是线性表）



便于插入和删除的容器有：list, map, set
1：vector 底层数据结构为数组，支持快速随机访问  2：list 底层数据结构为双向链表，支持快速增删 3：map、set都是STL关联容器，支持快速增删

Java：Serializable, Cloneable , Iterable <E>, Collection <E>, List <E>, RandomAccess List接口是有序的，通常允许重复The elements in the collection are ordered.
ArrayList是实现List 接口的大小可变数组ArrayList的实现是不是线程同步的
The elements in the collection are accessed using a unique key是Map的属性
    
    


在 C/C++ 中，若有定义 char a [10], *p=a; ，那么下列赋值语句正确的是(D )。
p="abcdefg"
双引号做了3件事：  1.申请了空间(在常量区)，存放了字符串 2. 在字符串尾加上了'/0'    3.返回地址
应该是a[10]="abcdefg"
a="abedefg"; a是数组首地址不能这样赋值
*p="abcdefg"  *p=a，也是指针地址变量,不能这样赋值

操作数组a[i][j]
*(*(a+i)+j)=1 = *(a[i]+j)=1
数组名当被直接使用时，是一个指向数组首地址的指针。如果数组是***数组，那么数组名是指向第一行数组的首地址，而不是第一行第一列单个元素的地址，所以*(a+i)与a[i]是一个意思，当直接用a[i]时代表的是该一维数组的首地址，所以*(a[i]+j)是与a[i][j]等效

设A是n*n的对称矩阵，将A的对角线及对角线上方的元素以列为主的次序存放在一维数组B[1..n（n+1）/2]中，对上述任一元素aij (1≤i，j≤n，且i≤j)在B中的位置为j（j-1）/2+i
以列为主；存储位置是从1开始的；如果没指明对角线是哪条，则默认为主对角线，即左上角到右下角。

将一个n×n的对称矩阵A的下三角部分按行存放在一个一维数组B中，A[0][0]存放在B[0]中，那么第i行的对角元素A[i][i]在B中的存放位置是( (i+3)×i/2 )
实际求的是对角线A[i][i]前面有多少元素，从0行开始到第i行是递增序列 等差数列求和公式：Sn=na1+n(n-1)d/2    经过代入整理得出：i(i+3)/2+1个元素，由于从0开始存储，所以i(i+3)/2



int c[4][5],( *pc)[5];    pc=c;
* (*pc+2)正确，
二维数组和一维数组的区别在于，二维数组可以理解为一维的一维。在一维中，*表示取数值，在二维中*表示取第几行的地址，**表示取值。 

压缩情况下，稀疏矩阵占用内存最少

char a[] = "ggood";  char b[];
编译错误：字符数组如果没有初始化，就必须指定大小，比如char c[10];如果进行了初始化，无须指定大小，比如char c[]="abcd";编译器会自动判断大小。字符数组名+1是char*类型，其实就是一个指针。本题把char b[]修改为char *b
b = a+1;  /b = &a[1];/char c="good", b=c; 都输出b为good


已知一稀疏矩阵的三组元表为：（1，2，3），（1，6，1），（3，1，5）（3，2，-1），（5，4，5）（5，1，-3），则其转置矩阵的三元组表中第3个三元组为（2,1,3）

稀疏矩阵：矩阵中大多数元素为0元素 用一个三元组存放矩阵中的元素，形式为( i，j，e) 其中i表示行号，j表示列号，e表示元素值 


线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。二维数组是每个元素都为线性表的线性表 .
每种数据结构都应具备三种基本运算：插入、删除和搜索。错误 栈就不能搜索
线性表的顺序存储结构中逻辑顺序与物理顺序总是一致的，但链式存储结构却不是
两种存储结构没有优劣之分，只是看在什么情况下适合哪种存储结构。对于经常插入或删除的


线性结构是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。   
  
常用的线性结构有：线性表，栈，队列，双队列，数组，串。    
    
   
 
  非线性结构中各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。根据关系的不同，可分为层次结构和群结构。  
 
  常见的非线性结构有：二维数组，***数组，广义表，树(二叉树等)，图。（其中***数组是由多个一维数组组成的，所以不再是线性结构） 



数组就是矩阵，矩阵就是数组，这种说法错误。数组中的元素可以是字符等；矩阵中的只能是数。数组是一种顺序存储的结构，矩阵是一种逻辑结构，可以使用数组，也可以使用链表。

如有定义：char str[20];，能将从键盘输入的字符串“How are you”保存到 str 数组的语句是（ gets(str)  ）
因为scanf不能输入空格，而gets函数却可以。  gets能够接受空格、制表符Tab和回车等。
 gets和sacnf函数，在字符串接受结束后自动加'\0'
scanf("%s", str); scanf()函数里输入空格，会被系统当作输入字符串之间的分隔符，认为当前字符串已经结束。所以str[20]中实际存储的是"How"。 
str[] = getch() 一次只能读取一个字符。 




# List
线性、单向、双向、循环链表

# 哈希表
高效数据检索

# Heap堆
实现优先队列

# 算法
排序算法、查找算法、递归和迭代、动态规划、分治算法、树的遍历、图的遍历
